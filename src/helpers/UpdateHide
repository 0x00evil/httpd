:
eval 'exec perl -S $0 ${1+"$@"}'
    if $running_under_some_shell;
##
##  UpdateHideHeader -- update include/hide.h header file
##  Written by Ralf S. Engelschall, <rse@apache.org>
##

#   the parameters
$httpdbinary = $ARGV[0];
$headerfile  = $ARGV[1];
$gnutriple   = $ARGV[2];

#   configuration
$listbegin  = '\n#ifdef HIDE\n';
$listend    = '\n#endif\n';
@excluded   = qw(
    main errno environ optarg
    dlclose dlerror dlopen dlsym
    start end atexit exit etext edata
);
@included   = qw(
    D:db_auth_module
    D:dbm_auth_module
);

#   determine os-dependend stuff
if ($gnutriple =~ m|.*-freebsd2.*|) {
    $nm_cmd   = '/usr/bin/nm -g';
    $us_strip = 1;
}
elsif ($gnutriple =~ m|.*-solaris2.*|) {
    $nm_cmd   = '/usr/ccs/bin/nm -p -g';
    $us_strip = 0;
}
elsif ($gnutriple =~ m|.*-hpux.*|) {
    $nm_cmd   = '/usr/ccs/bin/nm -p -g';
    $us_strip = 0;
}
else {
    print STDERR "Sorry, UpdateHide currently can be used only under\n";
    print STDERR "the following OS: FreeBSD, Solaris, HPUX\n";
    exit(1);
}

#   read current file as template
open(FP, "<$headerfile");
$header = '';
while (<FP>) {
    $header .= $_;
}
close(FP);

#   determine list of exported symbols
%SB = ();
%SD = ();
%ST = ();
@L = `$nm_cmd $httpdbinary`;
foreach $l (@L) {
    if ($l =~ m|^.*\s+([BDT])\s+(\S+)\s*$|) {
        ($type, $name) = ($1, $2);

        #   remove leading underscore (C linker convention)
        $name =~ s|^_|| if $us_strip;
        #   remove perhaps already existing AP_ prefix
        #   (when running this script while httpd was
        #    already compiled with HIDE defined)
        $name =~ s|^AP_||;  
        #   skip any compiler- or system-private symbols
        next if ($name !~ m|^[a-zA-Z]+|);
        #   skip any symbols in our exclusion list
        next if (grep(/$name/, @excluded));

        #   insert the symbol into our lists
        $SB{$name}++ if $type eq 'B';
        $SD{$name}++ if $type eq 'D';
        $ST{$name}++ if $type eq 'T';
    }
}
#   additionally add entries from static include list
foreach $i (@included) {
    ($type, $name) = ($i =~ m|^([BDT]):(.+)$|);
    $SB{$name}++ if $type eq 'B';
    $SD{$name}++ if $type eq 'D';
    $ST{$name}++ if $type eq 'T';
}

#   generate new redefinition list
sub mksublist {
    my ($name, %SL) = @_;
    my ($o, $s);

    $o .= "\n" .
          "/*\n" .
          " *  $name segment symbols\n" .
          " */\n";
    foreach $s (sort(keys(%SL))) {
        $o .= sprintf("#define %-30s AP_%s\n", $s, $s);
    }
    return $o;
}
$list = '';
$list .= &mksublist("BSS",  %SB);
$list .= &mksublist("Data", %SD);
$list .= &mksublist("Text", %ST);

#   replace old redefinition list with new one
$header =~ s|($listbegin).*?($listend)|$1$list$2|s;

#   write new header file
open(FP, ">$headerfile");
print FP $header;
close(FP);

##EOF##
